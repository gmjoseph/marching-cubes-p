<html>
    <head>
        <title>Marching Cubes Optimized - WebGL</title>
        <style>
            body {
                background-color: black;
                margin: 0;
                padding: 0;
                position: relative;
            }
            #main {
                display: flex;
                height: 100%;
                justify-content: center;
                align-items: center;
            }
            canvas {
                height: 100%;
            }
        </style>
    </head>
    <body>
        <section id="main">
            <canvas id="canvas" height="1024" width="1024"></canvas>
        </section>
    </body>
    <script src="lib/dat.gui.js"></script>
    <script src="lib/gl-matrix.js"></script>
    <script>

    /*
     * Random Learnings, Links, Resources
     *
     * = Per Vertex Normals =
     *
     * https://stackoverflow.com/questions/18519586/calculate-normal-per-vertex-opengl
     * http://www.euclideanspace.com/maths/algebra/vectors/applications/normals/index.htm
     * Per vertex normal
     * "We can now calculate this by adding the normals for each face adjoining the vertex, and then normalising."
     * I guess another option is that, because we're dealing with known shapes, we can use the gradient and get the
     * vector normal to the surface at the point... Though this won't work well after making modifications to the SDF.
     * const normal = averagedNormal(vert);
     *
     * Specific to marching cubes:
     * https://stackoverflow.com/a/21755487
     *
     * Gradient-based solution:
     * https://stackoverflow.com/a/29922941 (something about weighting, from GPU Gems 3 Ch 1)
     * https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-1-generating-complex-procedural-terrains-using-gpu
     * This relies on a density function being differentiable but i'm not sure if mine are (the SDFs might be...?), also based
     * on the code, it looks like they sample a texture and then do the gradient based on that, which won't work here
     * necessarily? (It does appear to be similar to what we do when we use the SDF below, so it makes sense):
     *
     * float d = 1.0/(float)voxels_per_block;
     * float3 grad;
     * grad.x = density_vol.Sample(TrilinearClamp, uvw + float3( d, 0, 0)) - density_vol.Sample(TrilinearClamp, uvw + float3(-d, 0, 0));
     * grad.y = density_vol.Sample(TrilinearClamp, uvw + float3( 0, d, 0)) - density_vol.Sample(TrilinearClamp, uvw + float3( 0,-d, 0));
     * grad.z = density_vol.Sample(TrilinearClamp, uvw + float3( 0, 0, d)) - density_vol.Sample(TrilinearClamp, uvw + float3( 0, 0,-d));
     * output.wsNormal = -normalize(grad);
     *
     * https://gamedev.stackexchange.com/a/97716 (basically use a structure to index tris/verts)
     *
     * Better solutions using cube corners + interpolation:
     * https://www.gamedev.net/forums/topic/526869-marching-cubes-vertex-normals/
     * "You can also create the normals directly from the volume data.. probably would look smoother if you did that.
     * Multiple ways to do it depending on if you want a smoother or more detailed appearance. If you don't know how to
     * do this, it is basically the same as finding the normal of a height field except you have a third dimension."
     * (since i'm working on a torus we can use torus data for that and gradients i guess?).
     * "Okay, I think I solved it. What I did is to calculate the vertex normal for each cube corner and then interpolate
     * it with the vertex values. Results look correct as far as I can tell. Is that a possible, correct way of doing it?"
     * "Yep, that should work. You don't need each cube corner though, as an vertex lies on one edge. So you just need to
     * interpolate between the normals at the two ends of the edge."
     *
     * https://www.gamedev.net/forums/topic/355340-calculating-vertex-normals-solved/
     * More helpful algorithms there
     *
     * https://www.iquilezles.org/www/articles/normals/normals.htm
     * Whole-mesh per-vertex normal computation. We'd need to setup the geometry properly post-march
     * to get this working.
     *
     * https://community.khronos.org/t/identifying-adjacent-triangles/32734/6
     * Helpful data structures for finding adjacency / shared faces.
     *
     * https://www.npmjs.com/package/simplicial-complex this will probably do the trick!
     *
     */

    // http://paulbourke.net/geometry/polygonise/
    // The tri table has 256 * 16 possible arrangements making 4096 things to pick from,
    // where 4096 in hex is 0x1000 which is why this goes from 0x0 -> 0xfff. As a result
    // it lets us pick which tris are made with edges from this table.
    const EDGE_TABLE = [
        0x0  , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
        0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
        0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
        0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
        0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c,
        0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
        0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac,
        0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
        0x460, 0x569, 0x663, 0x76a, 0x66 , 0x16f, 0x265, 0x36c,
        0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
        0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff , 0x3f5, 0x2fc,
        0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
        0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55 , 0x15c,
        0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
        0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc ,
        0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
        0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
        0xcc , 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
        0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
        0x15c, 0x55 , 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
        0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
        0x2fc, 0x3f5, 0xff , 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
        0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
        0x36c, 0x265, 0x16f, 0x66 , 0x76a, 0x663, 0x569, 0x460,
        0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
        0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0,
        0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
        0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230,
        0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
        0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190,
        0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
        0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0 
    ];

    // http://paulbourke.net/geometry/polygonise/
    const TRI_TABLE = [
        [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1],
        [3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1],
        [3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1],
        [3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1],
        [9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1],
        [1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1],
        [9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
        [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1],
        [8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1],
        [9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
        [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1],
        [3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1],
        [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1],
        [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1],
        [4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1],
        [9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1],
        [1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
        [5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1],
        [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1],
        [9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
        [0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
        [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1],
        [10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1],
        [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1],
        [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1],
        [5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1],
        [9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1],
        [0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1],
        [1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1],
        [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1],
        [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1],
        [2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1],
        [7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1],
        [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1],
        [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1],
        [11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1],
        [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1],
        [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1],
        [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1],
        [11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
        [1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1],
        [9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1],
        [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1],
        [2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
        [0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
        [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1],
        [6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1],
        [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1],
        [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1],
        [6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1],
        [5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1],
        [1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
        [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1],
        [6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1],
        [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1],
        [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1],
        [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1],
        [3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
        [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1],
        [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1],
        [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1],
        [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1],
        [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1],
        [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1],
        [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1],
        [10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1],
        [10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1],
        [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1],
        [1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1],
        [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1],
        [0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1],
        [10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1],
        [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1],
        [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1],
        [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1],
        [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1],
        [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1],
        [3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1],
        [6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1],
        [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1],
        [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1],
        [10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1],
        [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1],
        [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1],
        [7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1],
        [7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1],
        [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1],
        [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1],
        [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1],
        [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1],
        [0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1],
        [7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
        [10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
        [2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
        [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1],
        [7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1],
        [2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1],
        [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1],
        [10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1],
        [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1],
        [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1],
        [7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1],
        [6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1],
        [8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1],
        [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1],
        [6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1],
        [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1],
        [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1],
        [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1],
        [8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1],
        [0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1],
        [1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1],
        [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1],
        [10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1],
        [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1],
        [10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
        [5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
        [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1],
        [9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
        [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1],
        [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1],
        [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1],
        [7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1],
        [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1],
        [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1],
        [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1],
        [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1],
        [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1],
        [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1],
        [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1],
        [6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1],
        [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1],
        [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1],
        [6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1],
        [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1],
        [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1],
        [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1],
        [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1],
        [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1],
        [9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1],
        [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1],
        [1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1],
        [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1],
        [0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1],
        [5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1],
        [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1],
        [11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1],
        [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1],
        [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1],
        [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1],
        [2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1],
        [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1],
        [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1],
        [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1],
        [1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1],
        [9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1],
        [9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1],
        [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1],
        [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1],
        [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1],
        [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1],
        [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1],
        [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1],
        [9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1],
        [5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1],
        [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1],
        [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1],
        [8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1],
        [0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1],
        [9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1],
        [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1],
        [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1],
        [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1],
        [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1],
        [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1],
        [11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1],
        [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1],
        [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1],
        [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1],
        [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1],
        [1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1],
        [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1],
        [4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1],
        [0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1],
        [3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1],
        [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1],
        [0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1],
        [9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1],
        [1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
        [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
    ];

    // Using the mask against the value from EDGE_TABLE[edgeTableIndex], we determine whether
    // we should add the vertex we interpolate between corners[startIdx] and
    // corners[endIdx].
    // TODO
    // Using this would be a great way to help us index and reuse vertices across the same
    // triangle, as long as we know the index of the edge itself.
    // For example, if edge 1 is used in two cubes, then the vertex we get whe considering
    // edge 1 is the same for the triangles we'd get in the first cube and the second.
    const EDGE_TABLE_TO_VERT_LIST = [
        // back bottom
        { mask: 1, startIdx: 0, endIdx: 1 }, 
        // right bottom
        { mask: 2, startIdx: 1, endIdx: 2 }, 
        // front bottom
        { mask: 4, startIdx: 2, endIdx: 3 }, 
        // left bottom
        { mask: 8, startIdx: 3, endIdx: 0 }, 
        // back top
        { mask: 16, startIdx: 4, endIdx: 5 }, 
        // right top
        { mask: 32, startIdx: 5, endIdx: 6 }, 
        // front top
        { mask: 64, startIdx: 6, endIdx: 7 }, 
        // left top
        { mask: 128, startIdx: 7, endIdx: 4 }, 
        // back left
        { mask: 256, startIdx: 0, endIdx: 4 }, 
        // back right
        { mask: 512, startIdx: 1, endIdx: 5 }, 
        // front right
        { mask: 1024, startIdx: 2, endIdx: 6 }, 
        // front left
        { mask: 2048, startIdx: 3, endIdx: 7 }, 
    ];

    const { glMatrix } = window;

    const SHADER_NAME = 'shader';

    class SDF {
        constructor() {
            this.state = {
                animateTransition: false,
                sdfLibraryIndex: 0,
            }

            this.sdfLibrary = [
                // The default, regular old torus.
                // (p) => {
                //     let d = this.sdfTorus(p, 0.6, 0.2);
                //     return d;
                // },
                // Twisted torus
                (p) => {
                    p = this.opTwist(p);
                    let d = this.sdfTorus(p, 0.6, 0.2);
                    return d;
                },
                // A box hollowed out by an intersection with a sphere around the origin.
                (p) => {
                    let d = this.sdfBox(p, [0.4, 0.4, 0.4]);
                    let d1 = this.sdfSphere(p, 0.4, [0, 0, 0]);
                    d = this.opSmoothSubtraction(d1, d);
                    return d;
                },
                // A box hollowed out by an intersection with a sphere around the origin.
                (p) => {
                    let d = this.sdfBox(p, [0.4, 0.4, 0.4]);
                    let d1 = this.sdfSphere(p, 0.45, [0, 0, 0]);
                    d = this.opSmoothSubtraction(d1, d);
                    return d;
                },
                // A twisted, bent torus
                (p) => {
                    p = this.opBend(p);
                    p = this.opTwist(p);
                    let d = this.sdfTorus(p, 0.6, 0.2);
                    return d;
                },
                // A bent torus
                (p) => {
                    p = this.opBend(p);
                    let d = this.sdfTorus(p, 0.6, 0.2);
                    return d;
                },
                // A bulging box
                (p) => {
                    let d = this.sdfBox(p, [0.7, 0.2, 0.7]);
                    let d1 = this.sdfSphere(p, 0.6, [0, 0, 0]);
                    d = this.opSmoothUnion(d, d1);
                    // To subtract the sphere from the box.
                    // d = this.opSmoothSubtraction(d1, d);
                    return d;
                },
                // // 2 connected balls
                // (p) => {
                //     // p = this.opTwist(p);
                //     // If twisting, turn off per-vert normal and interpolate
                //     let d = this.sdfSphere(p, 2 * 0.175, [0, 0, 0]);
                //     let d1 = this.sdfSphere(p, 2 * 0.25, [-0.4, 0, 0.4]);
                //     d = this.opSmoothUnion(d, d1);
                //     // d = this.opSmoothSubtraction(d1, d);
                //     return d;
                // },
                // 5 connected balls in ascending size
                (p) => {
                    let d = this.sdfSphere(p, 0.35, [-0.45, -0.45, -0.45]);
                    let d1 = this.sdfSphere(p, 0.3, [-0.15, -0.15, -0.15]);
                    let d2 = this.sdfSphere(p, 0.25, [0.1, 0.1, 0.1]);
                    let d3 = this.sdfSphere(p, 0.2, [0.35, 0.35, 0.35])
                    let d4 = this.sdfSphere(p, 0.15, [0.45, 0.45, 0.45])
                    d = this.opSmoothUnion(d, d1);
                    d = this.opSmoothUnion(d, d2);
                    d = this.opSmoothUnion(d, d3);
                    d = this.opSmoothUnion(d, d4);
                    return d;
                },
                // 3 connected balls small-big-small
                (p) => {
                    let d = this.sdfSphere(p, 0.25, [-0.45, -0.45, -0.45]);
                    let d1= this.sdfSphere(p, 0.5, [0.0, 0.0, 0.0]);
                    let d2 = this.sdfSphere(p, 0.25, [0.45, 0.45, 0.45])
                    d = this.opSmoothUnion(d, d1);
                    d = this.opSmoothUnion(d, d2);
                    return d;
                },
                // Slightly twisted fat torus
                (p) => {
                    p = this.opTwist(p, 2);
                    let d = this.sdfTorus(p, 0.5, 0.4);
                    return d;
                },
                 // Very twisted fat torus
                 (p) => {
                    p = this.opTwist(p, 6);
                    let d = this.sdfTorus(p, 0.5, 0.4);
                    return d;
                },
                // Fat torus
                (p) => {
                    let d = this.sdfTorus(p, 0.5, 0.4);
                    return d;
                },
                // Elongated skinny torus
                (p) => {
                    const primitive = (p) => this.sdfTorus(p, 0.3, 0.1);
                    const d = this.opElongate(primitive, p, [0.3, 0.2, 0.3]);
                    return d;
                },
                // Bent, elongated skinny torus
                (p) => {
                    p = this.opBend(p, 0.2);
                    const primitive = (p) => this.sdfTorus(p, 0.3, 0.15);
                    const d = this.opElongate(primitive, p, [0.4, 0.4, 0.0]);
                    return d;
                },
                // Elongated, smoothunioned toruses.
                (p) => {
                    const dp1 = [p[0] - 0.28, p[1], p[2]];
                    const dp2 = [p[0] + 0.28, p[1], p[2]];
                    const p1 = (p) => this.sdfTorus([p[0] - 0.32, p[1], p[2]], 0.3, 0.15);
                    const p2 = (p) => this.sdfTorus([p[0] + 0.32, p[1], p[2]], 0.3, 0.15);
                    let d1 = this.opElongate(p1, p, [0, 0.3, 0]);
                    let d2 = this.opElongate(p2, p, [0, 0.3, 0]);
                    return this.opSmoothUnion(d1, d2);
                },
                // Bent fat torus, removed bad edges
                (p) => {
                    // don't include things beyond the x at a certain point.
                    const xBounds = 0.315;
                    p[0] = Math.max(-xBounds, Math.min(p[0], xBounds));
                    p = this.opBend(p, -5);
                    let d = this.sdfTorus(p, 0.7, 0.3);
                    return d;
                },
                // Bent fat torus, removed bad edges, bent further.
                (p) => {
                    // don't include things beyond the x at a certain point.
                    const xBounds = 0.6;
                    p[0] = Math.max(-xBounds, Math.min(p[0], xBounds));
                    p = this.opBend(p, -8);
                    let d = this.sdfTorus(p, 0.7, 0.3);
                    return d;
                },
                // Bent, elongated sphere along x.
                (p) => {
                    // don't include things beyond the x at a certain point.
                    p = this.opBend(p, -0.5);
                    const prim = (p) => this.sdfSphere(p, 0.5, [0, 0, 0]);
                    let d = this.opElongate(prim, p, [0.5, 0, 0]);
                    return d;
                },
                // A sphere cut by a box with some bending.
                (p) => {
                    p = this.opBend(p, -0.6);
                    let d = this.sdfBox(p, [0.7, 0.15, 0.7]);
                    let d1 = this.sdfSphere(p, 0.6, [0, 0, 0]);
                    d = this.opSmoothSubtraction(d, d1);
                    // To subtract the sphere from the box.
                    // d = this.opSmoothSubtraction(d1, d);
                    return d;
                },
            ];
            this.state.sdfLibraryIndex = this.sdfLibrary.length - 1;
            this.currentSdf = this.sdfLibrary[this.state.sdfLibraryIndex];
        }

        opSmoothUnion(d1, d2, k = 0.1) {
            // float opSmoothUnion( float d1, float d2, float k ) {
            // float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
            // return mix( d2, d1, h ) - k*h*(1.0-h); }
            // Mix:
            // https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mix.xhtml
            // x Specify the start of the range in which to interpolate.
            // y Specify the end of the range in which to interpolate.
            // a Specify the value to use to interpolate between x and y.
            // "x * (1 - a) + y * a"
            const v = 0.5 + 0.5 * (d2 - d1) / k;
            const h = Math.max(0, Math.min(v, 1));

            const mixed = d2 * (1 - h) + d1 * h;
            return mixed - k * h * (1 - h);
        }

        opSmoothSubtraction(d1, d2, k = 0.1) {
            // float opSmoothSubtraction( float d1, float d2, float k ) {
            // float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );
            // return mix( d2, -d1, h ) + k*h*(1.0-h); }
            const v = 0.5 - 0.5 * (d2 + d1) / k;
            const h = Math.max(0, Math.min(v, 1));

            const mixed = d2 * (1 - h) + -d1 * h;
            return mixed + k * h * (1 - h);
        }

        opSmoothIntersection(d1, d2, k = 0.1) {
            // float opSmoothIntersection( float d1, float d2, float k ) {
            // float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );
            // return mix( d2, d1, h ) + k*h*(1.0-h); }
            const v = 0.5 - 0.5 * (d2 - d1) / k;
            const h = Math.max(0, Math.min(v, 1));

            const mixed = d2 * (1 - h) + d1 * h;
            return mixed + k * h * (1 - h);
        }

        opTwist(p, k = 4.0) {
            // Twist amount.
            // NOTE:
            // Number of cubes has to be kind of high to get a good look out of this.
            const c = Math.cos(k * p[1]);
            const s = Math.sin(k * p[1]);
            const q = [
                p[0] * c + p[2] * -s,
                p[0] * s + p[2] * c,
                p[1],
            ];

            return q;
        }

        opBend(p, k = 1.0) {
            // float opCheapBend( in sdf3d primitive, in vec3 p )
            // {
            //     const float k = 10.0; // or some other amount
            //     float c = cos(k*p.x);
            //     float s = sin(k*p.x);
            //     mat2  m = mat2(c,-s,s,c);
            //     vec3  q = vec3(m*p.xy,p.z);
            //     return primitive(q);
            // }
            const c = Math.cos(k * p[0]);
            const s = Math.sin(k * p[0]);
            const q = [
                p[0] * c + p[1] * -s,
                p[0] * s + p[1] * c,
                p[2],
            ];
            return q;
        }

        opOnion(sdf, thickness) {
            return Math.abs(sdf) - thickness;
        }

        opElongate(sdfFunction, p, h) {
            // float opElongate( in sdf3d primitive, in vec3 p, in vec3 h )
            // {
            //     vec3 q = abs(p)-h;
            //     return primitive( max(q,0.0) ) + min(max(q.x,max(q.y,q.z)),0.0);
            // }
            const qx = Math.abs(p[0]) - h[0];
            const qy = Math.abs(p[1]) - h[1];
            const qz = Math.abs(p[2]) - h[2];

            const qMaxX = Math.max(qx, 0);
            const qMaxY = Math.max(qy, 0);
            const qMaxZ = Math.max(qz, 0);

            const d = sdfFunction([qMaxX, qMaxY, qMaxZ]) + Math.min(Math.max(qx, Math.max(qy, qz)), 0);
            return d;
        }

        sdfSphere(p, radius, c) {
            const magnitude = Math.sqrt(
                (p[0] - c[0]) ** 2 +
                (p[1] - c[1]) ** 2 +
                (p[2] - c[2]) ** 2
            );
            return magnitude - radius;
        }

        sdfTorus(p, r1, r2) {
            const qx = Math.sqrt(p[0] ** 2 + p[2] ** 2) - r1;
            const qy = p[1];
            
            return  Math.sqrt(qx ** 2 + qy ** 2) - r2;
        }

        sdfBox(p, dimension) {
            const qx = Math.abs(p[0]) - dimension[0];
            const qy = Math.abs(p[1]) - dimension[1];
            const qz = Math.abs(p[2]) - dimension[2];

            const qmx = Math.max(qx, 0.0);
            const qmy = Math.max(qy, 0.0);
            const qmz = Math.max(qz, 0.0);
            return Math.sqrt(qmx ** 2 + qmy ** 2 + qmz ** 2) + Math.min(Math.max(qx,Math.max(qy,qz)),0.0);
        }

        sdfOctahedron(p, s) {
            // float sdOctahedron( vec3 p, float s)
            // {
            // p = abs(p);
            // float m = p.x+p.y+p.z-s;
            // vec3 q;
            //     if( 3.0*p.x < m ) q = p.xyz;
            // else if( 3.0*p.y < m ) q = p.yzx;
            // else if( 3.0*p.z < m ) q = p.zxy;
            // else return m*0.57735027;
                
            // float k = clamp(0.5*(q.z-q.y+s),0.0,s); 
            // return length(vec3(q.x,q.y-s+k,q.z-k)); 
            // }

            const px = Math.abs(p[0]);
            const py = Math.abs(p[1]);
            const pz = Math.abs(p[2]);
            let qx;
            let qy;
            let qz;
        
            const m = px + py + pz - s;
            if (3 * px < m) {
                qx = px;
                qy = py;
                qz = pz;
            } else if (3 * py < m) {
                qx = py;
                qy = pz;
                qz = px;
            } else if (3 * pz < m) {
                qx = pz;
                qy = px;
                qz = py;
            } else {
                return m * 0.57735027;
            }

            const k = Math.max(0, Math.min(0.5 * (qz - qy + s), s));

            return Math.sqrt(qx ** 2 + (qy - s + k) ** 2 + (qz - k) ** 2);
        }
    }

    class Shader {
        constructor(gl, vertCode, fragCode) {
            this.program = null;
            this.setupShader(gl, vertCode, fragCode);
        }

        setupShader(gl, vertCode, fragCode) {
            const log = (shader) => {
                const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
                if (!compiled) {
                    console.log('Shader compiled failed: ' + compiled);
                
                    const compilationLog = gl.getShaderInfoLog(shader);
                    console.log('Shader compiler log: ' + compilationLog);
                }
            };

            const vertShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertShader, vertCode);
            gl.compileShader(vertShader);
            log(vertShader);
            
        
            const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragShader, fragCode); 
            gl.compileShader(fragShader);
            log(fragShader);
            
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertShader);
            gl.attachShader(shaderProgram, fragShader);
            gl.linkProgram(shaderProgram);

            this.program = shaderProgram
        }

        cacheUniformLocations(gl, uniformNames) {
            uniformNames.forEach(name => {
                const key = `${name}Location`;
                this[key] = gl.getUniformLocation(this.program, name);
            });
        }

        cacheAttributeLocations(gl, attributeNames) {
            attributeNames.forEach(name => {
                const key = `${name}Location`;
                const location = gl.getAttribLocation(this.program, name);
                this[key] = location;
            });
        }
    }

    class MarchingCubes {
        constructor(sdf, viz) {
            this.sdf = sdf;
            this.viz = viz;
            this.size = 2;
            this.cubeSize = 0.2;
            this.toggleInterpolate = true;
            this.togglePerVertexNormals = true;
            this.toggleMarchingCubesDebug = false;

            this.directions = [
                'FORWARD',
                'BACKWARD',
                'UP',
                'DOWN',
                'LEFT',
                'RIGHT',
            ];

            // All three of these should have the same length.
            // vertexIndexToCorner:
            //  This has a number and maps it to one vertex. That vertex is a cube corner. These
            //  are shared by multiple cubes.
            this.vertexIndexToCorner = [];
            // vertexIndexToCornersGraph:
            //  This also uses the same number, but it's a graph of what other vertices
            //  are associated with this corner. For example, we can find the vertex
            //  before it, above it, to the left or right of it, or up and down from it
            //  it's basically like a graph with a node. Also belongs to a cube, basically.
            this.vertexIndexToCornersGraph = [];
            // vertexIndexToSdfValue
            //  Evaluate the SDF at the corner and cache it while we're iterating over them.
            //  This lets us reuse an sdf for a corner vertex shared by multiple cubes.
            this.vertexIndexToSdfValue = [];

            // These must persist across invocations of toTriangles();
            // vertexIndexToTriangleVertex:
            //  Now this is for actual interpolated vertices that we'll render. It's a number
            //  that maps to a vertex for a triangle.
            //  Every value we put into vertList[i] will actually be the index of the vertex in
            //  this array. This also is a deduplication measure since we already use similar
            //  values for edges.
            this.vertexIndexToTriangleVertex = [];
            // vertexIndexToVertexNormal:
            //  Holds each normal that corresponds to each vertexIndexToTriangleVertex. Basically
            //  the indices should match, and so should the lengths of these two, since it's just
            //  the normals counterpart to the positions (i.e. triangle vertices).
            this.vertexIndexToVertexNormal = [];
            // edgeToVertexIndex:
            //  As we invoke toTriangles, we want to cache vertices we've computed using linear
            //  interpolation. This caches vertices by which edge they belong to, using a combined
            //  key of the start and endpoints, and it maps it to the same index we'd find in
            //  vertexIndexToTriangleIndex.
            this.edgeToVertexIndex = {}
            // triangles:
            //  All the triangles made up of indices that map from here into vertexIndexToTriangleVertex.
            //  Indices must point to a whole vertex (i.e. the highest index should not be bigger than
            //  vertexIndexToTriangleVertex.length / 3).
            this.triangles = [];

            // vertList:
            //  Used internally for generateTriangles. Instantiating it once here, becuase we can
            //  reuse its memory across calls to generateTriangles
            this.vertList = new Array(12);

            const stateDefaults = {
                buffer: null,
                data: null,
                callback: null,
                enabled: true,
                hasIndices: false,
                hasNormals: false,
            };

            this.state = {
                grid: {
                    ...stateDefaults,
                    colour: new Float32Array([1.0, 1.0, 1.0]),
                    opacity: 0.2,
                },
                boundingBox: {
                    ...stateDefaults,
                    colour: new Float32Array([1.0, 1.0, 1.0]),
                    opacity: 1,
                },
                regularMesh: {
                    ...stateDefaults,
                    colour: new Float32Array([1, 0, 0]),
                    opacity: 1,
                    hasNormals: true,
                },
                indexedMesh: {
                    ...stateDefaults,
                    colour: new Float32Array([0, 0, 1]),
                    opacity: 1,
                    vertices: {},
                    normals: {},
                    indices: {},
                    hasIndices: true,
                    hasNormals: true,
                },
            };
        }

        nextSdf = () => {
            this.sdf.state.sdfLibraryIndex++;
            if (this.sdf.state.sdfLibraryIndex >= this.sdf.sdfLibrary.length) {
                this.sdf.state.sdfLibraryIndex = 0;
            }
            this.sdf.currentSdf = this.sdf.sdfLibrary[this.sdf.state.sdfLibraryIndex];
            this.march();
        }

        updateGrid() {
            if (!this.state.grid.enabled) {
                return;
            }
            const start = -this.size * 0.5;
            const end = this.size * 0.5;
            const { cubeSize: s } = this;

            // Draw a 3d grid, rather than trying to wireframe the cubes.
            const lines = [];
            // lines left to right
            for (let y = start; y <= end; y += s) {
                for (let z = start; z <= end; z += s) {
                    lines.push(start, y, z);
                    lines.push(end, y, z);
                }
            }

            // lines bottom to top
            for (let x = start; x <= end; x += s) {
                for (let z = start; z <= end; z += s) {
                    lines.push(x, start, z);
                    lines.push(x, end, z);
                }
            }
            // lines back to front.
            for (let x = start; x <= end; x += s) {
                for (let y = start; y <= end; y += s) {
                    lines.push(x, y, start);
                    lines.push(x, y, end);
                }
            }

            this.state.grid.data = new Float32Array(lines);
            this.state.grid.callback = (gl) => gl.drawArrays(gl.LINES, 0, lines.length / 3);
            viz.setupBuffer(this.state.grid);
        }


        getNeighbourGraph(vertexIndex, direction, x, y, z) {
            // Given a direction, we can get the index of the vertex there.
            const { size, cubeSize } = this;
            const start = -size * 0.5;
            const end = size * 0.5;
            
            const nextRow = (size + cubeSize) / cubeSize;
            const nextPlane = nextRow ** 2;
            
            let nextIndex;

            switch (direction) {
                // These are neighbouring in the array because the innermost loop is +/-z
                case 'FORWARD':
                    nextIndex = vertexIndex + 1; break;
                case 'BACKWARD':
                    nextIndex = vertexIndex - 1; break;
                // These are one row off, since the next innermost loop is +/-y
                // We work bottom to top, so the next values come in first making the more positive
                // values on the next row.
                case 'UP':
                    nextIndex = vertexIndex + nextRow; break;
                case 'DOWN': 
                    nextIndex = vertexIndex - nextRow; break;
                // These are one plane off, since the outermost loop is +/x, which means
                // we make an entire plane (along yz) before we even increment to the next x.
                case 'LEFT':
                    nextIndex = vertexIndex - nextPlane; break;
                case 'RIGHT':
                    nextIndex = vertexIndex + nextPlane; break;
            }

            // Out of bounds in these cases             
            const isBackColumn = z === start && direction === 'BACKWARD';
            const isFrontColumn = z === end && direction === 'FORWARD';

            const isTopRow = y === end && direction === 'UP';
            const isBottomRow = y === start && direction === 'DOWN';

            const isleftPlane = x === start && direction === 'LEFT';
            const isRightPlane = x === end && direction === 'RIGHT';

            // We'd collide if we try to use an index outside of htese bounds.
            if (isBackColumn ||
                isFrontColumn ||
                isTopRow ||
                isBottomRow ||
                isleftPlane ||
                isRightPlane
            ) {
                nextIndex = null;
            }
            return nextIndex;
        }

        indexCorners() {
            // see if we can get all the points and index them so that we then know which edge uses them
            // and so on.
            // i.e. we never refer to vertices from the cube, instead we store them all by an index so that
            // we can reuse, and then we can index the output verts from marching because if vert10 <-> vert11
            // produced an intersection, it doesn't matter if it's the edge shared by the current (or next,
            // or previous box, depending on which edge is shared), because it's still the same two points
            // being tested.
            const { size, cubeSize: s } = this;
            const start = -size * 0.5;
            const end = size * 0.5;

            let totalIndex = 0;
            for (let x = start; x <= end; x += s) {
                for (let y = start; y <= end; y += s) {
                    for (let z = start; z <= end; z += s) {
                        // TODO
                        // If we want flat shading, we can make each of these unique to a cube, rather than
                        // sharing them with other cubes.

                        // lets us resolve a vertex using its index to the underlying x, y, z values.
                        const vertex = [x, y, z];
                        this.vertexIndexToCorner.push(vertex);

                        // directional graph
                        const graph = {};
                        this.directions.forEach(direction => {
                            graph[direction] = this.getNeighbourGraph(totalIndex, direction, x, y, z);
                        })
                        this.vertexIndexToCornersGraph.push(graph);

                        // stores the sdf value per-vertex index as well for reuse later on.
                        const sdfValue = this.sdf.currentSdf(vertex);
                        this.vertexIndexToSdfValue.push(sdfValue);

                        totalIndex++;
                    }
                    // console.log("vi after one row", cornersRunningIndex);
                }
                // console.log("vi after one plane", cornersRunningIndex);
            }

            if (this.vertexIndexToCorner.length !== this.vertexIndexToCornersGraph.length){
                throw new Error("inconsistent lengths", this.vertexIndexToCorner.length, this.vertexIndexToCornersGraph.length);
            }
        }

        // Midpoint interpolation.
        getVertMidpoint(p1, p2) {
            const p = new Array(3);
            p[0] = (p1[0] + p2[0]) * 0.5;
            p[1] = (p1[1] + p2[1]) * 0.5;
            p[2] = (p1[2] + p2[2]) * 0.5;
            return p;
        }
        
        // http://paulbourke.net/geometry/polygonise/
        getVertInterpolated(p1, p2, valp1, valp2) {
            // Some random value we pick afaict. But since we use an isolevel
            // of 0 to determine inside or outside (i.e. any value < 0 is inside)
            // we should be able to just set this to 0 and leave it at that.
            const isolevel = 0.0;
            // const epsilon = 0.00001;
            const epsilon = 0;
            const p = new Array(3);

            if (Math.abs(isolevel - valp1) < epsilon) {
                return p1;
            }
            if (Math.abs(isolevel - valp2) < epsilon) {
                return p2;
            }
            if (Math.abs(valp1 - valp2) < epsilon) {
                return p1;
            }

            const mu = (isolevel - valp1) / (valp2 - valp1);
            p[0] = p1[0] + mu * (p2[0] - p1[0]);
            p[1] = p1[1] + mu * (p2[1] - p1[1]);
            p[2] = p1[2] + mu * (p2[2] - p1[2]);

            return p;
        }

        generatePerTriangleNormal(v1, v2, v3) {
            // v1, v2, v3 are just indices, so we need to resolve them to actual vertices
            const v1x = this.vertexIndexToTriangleVertex[v1 * 3];
            const v1y = this.vertexIndexToTriangleVertex[v1 * 3 + 1];
            const v1z = this.vertexIndexToTriangleVertex[v1 * 3 + 2];

            const v2x = this.vertexIndexToTriangleVertex[v2 * 3];
            const v2y = this.vertexIndexToTriangleVertex[v2 * 3 + 1];
            const v2z = this.vertexIndexToTriangleVertex[v2 * 3 + 2];

            const v3x = this.vertexIndexToTriangleVertex[v3 * 3];
            const v3y = this.vertexIndexToTriangleVertex[v3 * 3 + 1];
            const v3z = this.vertexIndexToTriangleVertex[v3 * 3 + 2];

            // compute normal with cross product between the vectors made by the vertices
            const ax = v2x - v1x;
            const ay = v2y - v1y;
            const az = v2z - v1z;

            const bx = v3x - v1x;
            const by = v3y - v1y;
            const bz = v3z - v1z;

            // We get lucky in that winding in this direction seems to guarantee, always,
            // an outward orientation for the normal.
            const nx = ay * bz - az * by;
            const ny = -(ax * bz - az * bx);
            const nz = ax * by - ay * bx;
            return [nx, ny, nz];
        }

        generatePerVertexNormal(vertex) {
            const v = vertex;
            const { currentSdf } = this.sdf;
            /*
                * Basically gives us the per-vertex normal. If we don't use this approach, we'll have to
                * later on:
                * 1. for each vertex
                * 2. figure out which triangles touch it.
                * 3. take the normal of each triangle
                * 4. add them all together to average each triangles contribution
                * 5. make that normal the per-vertex normal
                * Based on how we generate the mesh, finding the triangles that a vertex shares is
                * cumbersome, but it might be worthwhile doing later on to cut down on geometry and use
                * indexing + drawElements.
                * See the comments at the very top for more info and links on per-vertex normals.
                */

            // https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm
            // vec3 calcNormal( in vec3 p ) // for function f(p)
            // {
            //     const float eps = 0.0001; // or some other value
            //     const vec2 h = vec2(eps,0);
            //     return normalize( vec3(f(p+h.xyy) - f(p-h.xyy),
            //                         f(p+h.yxy) - f(p-h.yxy),
            //                         f(p+h.yyx) - f(p-h.yyx) ) );
            // }
            const eps = 0.00001;
            const x = currentSdf([v[0] + eps, v[1], v[2]]) - currentSdf([v[0] - eps, v[1], v[2]]);
            const y = currentSdf([v[0], v[1] + eps, v[2]]) - currentSdf([v[0], v[1] - eps, v[2]]);
            const z = currentSdf([v[0], v[1], v[2] + eps]) - currentSdf([v[0], v[1], v[2] - eps]);

            return [x, y, z];
        }

        generateTriangles(corners, edgeTableIndex) {
            const { vertexIndexToSdfValue, vertexIndexToCorner } = this;
            const getVert = this.toggleInterpolate ? this.getVertInterpolated : this.getVertMidpoint;
            
            if (EDGE_TABLE[edgeTableIndex] == 0) {
                // Cube is entirely in/out of the surface
                return;
            }

            // The amount of actual verts we make, they should be deduplicate.
            EDGE_TABLE_TO_VERT_LIST.forEach(({ mask, startIdx, endIdx }, i) => {
                if (EDGE_TABLE[edgeTableIndex] & mask) {
                    const idx1 = corners[startIdx]
                    const idx2 = corners[endIdx];
                    const corner1 = vertexIndexToCorner[idx1];
                    const corner2 = vertexIndexToCorner[idx2];
                    const sdf1 = vertexIndexToSdfValue[idx1];
                    const sdf2 = vertexIndexToSdfValue[idx2];
                    // Find the vertices where the surface intersects the cube
                    // This must be between the corners[startIdx] and corners[endIdx] (i.e. it's
                    // some percentage along this line).
                    // Another thing that must be true is that if the sdfValues[startIdx] is > 0
                    // then sdfValues[endIdx] is < 0 or vice versa to show we're crossing the surface.
                    const key = `${idx1}-${idx2}`;

                    let index;
                    if (this.edgeToVertexIndex[key]) {
                        // Vert already exists, so we can just use the index directly, thereby reusing
                        // the vert. This allows us to index later.
                        index = this.edgeToVertexIndex[key];
                    } else {
                        // New vert added.
                        // index = this.vertexIndexToTriangleVertex.length;
                        // If we're expanding everything here, then we / 3 to get the index -> vertex
                        // since the vertex has 3 components.
                        index = this.vertexIndexToTriangleVertex.length / 3;
                        const triangleVert = getVert(corner1, corner2, sdf1, sdf2);
                        this.edgeToVertexIndex[key] = index;
                        // this.vertexIndexToTriangleVertex.push(triangleVert);
                        // Push expanded, so we can use it directly for a buffer.
                        this.vertexIndexToTriangleVertex.push(...triangleVert);

                        if (this.togglePerVertexNormals) {
                            // If it's per-vertex normals, we can compute it here. Otherwise if it's using
                            // the triangle's surface normal, and sharing that with all three vertices, we
                            // need to compute that when we have all three vertices making up the triangle face.
                            const normal = this.generatePerVertexNormal(triangleVert);
                            this.vertexIndexToVertexNormal.push(...normal);
                        }
                    }

                    // We use the index to a vertex index for finding the -real- vertices.
                    this.vertList[i] = index;
                }
            });

            // Look up triangles in the TRI_TABLE until we encounter a -1 for the current index.
            // If we hit -1 it means that no further vertices are defined for the tri.
            for (let i = 0; TRI_TABLE[edgeTableIndex][i] != -1; i += 3) {
                // const triangle = [
                //     // The TRI_TABLE will give us an edgeTableIndex into the verlist.
                //     // e.g. if the edgeTableIndex is 64 (0x40), then we get the following triangle indices:
                //     // [10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
                //     // This means we now use 10, 6, and 5 as look ups into the vertList.
                //     // In turn, the vertList can have missing entires for all the other values, as
                //     // long as there is something at 10, 6, and 5.
                //     this.vertList[TRI_TABLE[edgeTableIndex][i]],
                //     this.vertList[TRI_TABLE[edgeTableIndex][i + 1]],
                //     this.vertList[TRI_TABLE[edgeTableIndex][i + 2]],
                // ];
                // // Create all the vertices that the triangles use via their indexed value.
                // this.triangles.push(triangle);
                // // Push expanded, so we can use it directly for a buffer.

                // Push expanded, so we can use it directly for a buffer.
                const v1 = this.vertList[TRI_TABLE[edgeTableIndex][i]];
                const v2 = this.vertList[TRI_TABLE[edgeTableIndex][i + 1]];
                const v3 = this.vertList[TRI_TABLE[edgeTableIndex][i + 2]];
                // Use the three vertices at the indices v1, v2, v3 to draw this triangle.
                // v1, v2, v3 point to the start of the vert's x coordinate, so to get back to
                // the table we'd need to do:
                // verts[v1 * 3 + 0] = x
                // verts[v1 * 3 + 1] = y
                // verts[v1 * 3 + 2] = z
                // and so on.
                this.triangles.push(v1, v2, v3);

                // if (!this.togglePerVertexNormals) {
                //     // TODO
                //     // Pretty sure for a good flat-shaded look, we can't share vertices and normals, because
                //     // we're assigning this normal to a vert, but the vert is possibly shared by 6 triangles.
                //     // As a result, we may have computed a normal for one of the triangles that the vert belonged
                //     // to, but we're then assuming that that normal would be equally valid for the other triangles
                //     // shared by the vert, which it is not.

                //     // We now need to compute a normal for the entire triangle. That normal will be used
                //     // by each of these verts. Because we're flattening everything, we need the v1, v2, v3
                //     // values to point to the beginning of the normal vec3.
                //     const normal = this.generatePerTriangleNormal(v1, v2, v3);
                //     if (this.vertexIndexToVertexNormal[v1 * 3] === undefined) {
                //         this.vertexIndexToVertexNormal.splice(v1 * 3, 0, ...normal);
                //     }
                //     if (this.vertexIndexToVertexNormal[v2 * 3] === undefined) {
                //         this.vertexIndexToVertexNormal.splice(v2 * 3, 0, ...normal);
                //     }
                //     if (this.vertexIndexToVertexNormal[v3 * 3] === undefined) {
                //         this.vertexIndexToVertexNormal.splice(v3 * 3, 0, ...normal);
                //     }
                // }
            }
        }

        generateTrianglesFromCorners() {
            //  Assume that each vertex is the bottom-top-left corner of the cube.
            // Order we want to go is:
            //  bottom back left
            //  bottom back right
            //  bottom front right
            //  bottom front left
            //  top back left
            //  top back right
            //  top front right
            //  top front left
            // Given the SDR values we computed for the corner, we build a mask in to the edge table
            // index for this  cube.

            const { vertexIndexToCorner, vertexIndexToCornersGraph, vertexIndexToSdfValue } = this;
            for (let vertexIndex = 0; vertexIndex < vertexIndexToCorner.length; vertexIndex++) {
                const sdfValue = vertexIndexToSdfValue[vertexIndex];
                // Bottom graph values.
                const backLeftGraph = vertexIndexToCornersGraph[vertexIndex];
                if (!backLeftGraph.RIGHT ||
                    !backLeftGraph.FORWARD ||
                    !backLeftGraph.UP) {
                    // On the edge, so we can't move ward
                    // Should be % {11, 121, 121 * 11, given the current sizing} == 0 
                    // console.log(vertexIndex);
                    continue;
                }
                const backRightGraph = vertexIndexToCornersGraph[backLeftGraph.RIGHT];
                if (!backRightGraph) {
                    // TODO
                    // I think there's a bug when finding directions that is adding things that aren't possible.
                    continue;
                }

                const frontRightGraph = vertexIndexToCornersGraph[backRightGraph.FORWARD];
                const frontLeftGraph = vertexIndexToCornersGraph[backLeftGraph.FORWARD];

                if (!frontRightGraph || !frontLeftGraph) {
                    // TODO
                    // I think there's a bug when finding directions that is adding things that aren't possible.
                    continue;
                }

                // Bottom indices => vertex x, y, z values.
                const corners = [
                    // const backLeft = 
                    vertexIndex,
                    // const backRight = 
                    backLeftGraph.RIGHT,
                    // const frontRight = 
                    backRightGraph.FORWARD,
                    // const frontLeft = 
                    backLeftGraph.FORWARD,

                    // Top indices
                    // const topBackLeft = 
                    backLeftGraph.UP,
                    // const topBackRight = 
                    backRightGraph.UP,
                    // const topFrontRight = 
                    frontRightGraph.UP,
                    // const topFrontLeftGraph = 
                    frontLeftGraph.UP,
                ];

                let edgeTableIndex = 0;

                for (let i = 0; i < corners.length; i++) {
                    // The corners just store index numbers after all.
                    const corner = corners[i];

                    // Check if this cube's corner is inside, and build up the edgeTableIndex
                    // conditionally.
                    const sdfValue = vertexIndexToSdfValue[corner];
                    if (sdfValue < 0) {
                        continue;
                    }
                    const mask = 2 ** i;
                    edgeTableIndex |= mask;
                }

                if (edgeTableIndex) {
                    // Generate from triangles.
                    this.generateTriangles(corners, edgeTableIndex);
                }
            }
        }

        marchCubes() {
            // Populates:
            // this.vertexIndexToCorner
            // this.vertexIndexToCornersGraph
            // this.vertexIndexToSdfValue
            this.indexCorners();

            // Populates:
            // this.vertexIndexToTriangleVertex
            // this.edgeToVertexIndex
            // this.triangles
            this.generateTrianglesFromCorners();

            if (this.togglePerVertexNormals) {
            
                // At this point we have 
                //  * All triangles (made up of indices into vertexIndexToTriangleVertex)
                //  * All the vertices mapped by their index (in vertexIndexToTriangleVertex)
                // It's enough to draw them using drawElements.
                this.state.indexedMesh.vertices.data = new Float32Array(this.vertexIndexToTriangleVertex);
                this.state.indexedMesh.normals.data = new Float32Array(this.vertexIndexToVertexNormal);
                this.state.indexedMesh.indices.data = new Uint32Array(this.triangles);
                viz.setupBuffer(this.state.indexedMesh.vertices);
                viz.setupBuffer(this.state.indexedMesh.normals);
                viz.setupBuffer(this.state.indexedMesh.indices, 'ELEMENT_ARRAY_BUFFER');

                this.state.indexedMesh.callback = (gl) => {
                    // Might need to go to unsigned short (gl.UNSIGNED_SHORT), should work for number of indices.
                    gl.drawElements(gl.TRIANGLES, this.state.indexedMesh.indices.data.length, gl.UNSIGNED_INT, 0);
                }   
            } else {
                // We're preparing a mesh here that is based on the same data as above, but it won't use
                // any indexing. That way each vert belonging to a tri can share the normal of that tri.
                // We could also do normal smoothing for this, but the version above is the same thing,
                // just faster.
                // When this is not per-vertex also, then vertexIndexToVertexNormal should be empty because
                // we need to compute that now.
                if (this.vertexIndexToVertexNormal.length) {
                    throw new Error("needlessly generated per-vertex normals.");
                }

                // For each triangle, expand its vertices into a per-triangle vertex array. This results in
                // duplication. At the same time, make the per-triangle normal and assign it to each vertex.
                // The buffer will be interleaved to at least get some speed there.
                // 3 vertices per triangle. 3 x, y, z and 3 nx, ny, nz values.
                // Since they're with their indices, e.g. tri 1 = v0, v1, v2.
                const vertexNormalData = new Float32Array(this.triangles.length * (3 + 3));
                let vertexNormalDataIndex = 0;
                for (let i = 0; i < this.triangles.length; i += 3) {
                    // These are just indices, we need to get the real x, y, z vertex data behind them.
                    const v1 = this.triangles[i];
                    const v2 = this.triangles[i + 1]
                    const v3 = this.triangles[i + 2];

                    const normal = this.generatePerTriangleNormal(v1, v2, v3);

                    // v1 x, y, z, nx, ny, nz
                    vertexNormalData[vertexNormalDataIndex + 0] = this.vertexIndexToTriangleVertex[v1 * 3];
                    vertexNormalData[vertexNormalDataIndex + 1] = this.vertexIndexToTriangleVertex[v1 + 1 * 3];
                    vertexNormalData[vertexNormalDataIndex + 2] = this.vertexIndexToTriangleVertex[v1 + 2 * 3];
                    vertexNormalData[vertexNormalDataIndex + 3] = normal[0];
                    vertexNormalData[vertexNormalDataIndex + 4] = normal[1];
                    vertexNormalData[vertexNormalDataIndex + 5] = normal[2];

                    // v2 x, y, z, nx, ny, nz
                    vertexNormalData[vertexNormalDataIndex + 6] = this.vertexIndexToTriangleVertex[v2 * 3];
                    vertexNormalData[vertexNormalDataIndex + 7] = this.vertexIndexToTriangleVertex[v2 + 1 * 3];
                    vertexNormalData[vertexNormalDataIndex + 8] = this.vertexIndexToTriangleVertex[v2 + 2 * 3];
                    vertexNormalData[vertexNormalDataIndex + 9] = normal[0];
                    vertexNormalData[vertexNormalDataIndex + 10] = normal[1];
                    vertexNormalData[vertexNormalDataIndex + 11] = normal[2];

                    // v3 x, y, z, nx, ny, nz
                    vertexNormalData[vertexNormalDataIndex + 12] = this.vertexIndexToTriangleVertex[v3 * 3];
                    vertexNormalData[vertexNormalDataIndex + 13] = this.vertexIndexToTriangleVertex[v3 + 1 * 3];
                    vertexNormalData[vertexNormalDataIndex + 14] = this.vertexIndexToTriangleVertex[v3 + 2 * 3];
                    vertexNormalData[vertexNormalDataIndex + 15] = normal[0];
                    vertexNormalData[vertexNormalDataIndex + 16] = normal[1];
                    vertexNormalData[vertexNormalDataIndex + 17] = normal[2];

                    vertexNormalDataIndex += 18;
                }

                this.state.regularMesh.data = new Float32Array(vertexNormalData);
                viz.setupBuffer(this.state.regularMesh);

                this.state.regularMesh.callback = (gl) => {
                    gl.drawArrays(gl.TRIANGLES, 0, this.state.regularMesh.data.length / 6);
                }   
            }
        }

        updateBoundingBox() {
            if (!this.state.boundingBox.enabled) {
                return;
            }
            const start = -this.size * 0.5;
            const end = this.size * 0.5;
            const { cubeSize: s } = this;

            // Draw a bounding box around the march area for debug/viz.
            const lines = [];

            // lines left to right
            lines.push(start, start, start);
            lines.push(end, start, start);
            lines.push(start, end, start);
            lines.push(end, end, start);
            lines.push(start, start, end);
            lines.push(end, start, end);
            lines.push(start, end, end);
            lines.push(end, end, end);

            // // lines bottom to top
            lines.push(start, start, start);
            lines.push(start, end, start);
            lines.push(end, start, start);
            lines.push(end, end, start);
            lines.push(start, start, end);
            lines.push(start, end, end);
            lines.push(end, start, end);
            lines.push(end, end, end);

            // lines back to front.
            lines.push(start, start, start);
            lines.push(start, start, end);
            lines.push(end, start, start);
            lines.push(end, start, end);
            lines.push(start, end, start);
            lines.push(start, end, end);
            lines.push(end, end, start);
            lines.push(end, end, end);

            this.state.boundingBox.data = new Float32Array(lines);
            this.state.boundingBox.callback = (gl) => gl.drawArrays(gl.LINES, 0, lines.length / 3);
            viz.setupBuffer(this.state.boundingBox);            
        }

        reset() {
            this.vertexIndexToCorner = [];
            this.vertexIndexToCornersGraph = [];
            this.vertexIndexToSdfValue = [];
            this.vertexIndexToTriangleVertex = [];
            this.vertexIndexToVertexNormal = [];
            this.edgeToVertexIndex = {}
            this.triangles = [];
            this.vertList = new Array(12);
        }

        march = () => {
            this.reset();
            this.updateGrid();
            this.updateBoundingBox();
            this.marchCubes();
        }
    }

    class Viz {
        constructor() {
            this.canvas = document.getElementById('canvas');
            this.ctx = this.canvas.getContext('webgl2', {
                alpha: true,
                antialias: true,
                depth: true,
                premultipliedAlpha: false,
            });
            this.state = {};
            this.cameraPosition = {
                x: 0,
                y: 0,
                z: 4,
            };

            this.setupMatrices();
            this.setupGL();
        }

        setupMatrices = () => {
            const { mat4, vec3 } = glMatrix;
            this.modelMatrix = mat4.create();

            this.viewMatrix = mat4.create();
            // viewer centre, view direction, up
            const { x, y, z } = this.cameraPosition;
            mat4.lookAt(this.viewMatrix, vec3.fromValues(x, y, z), vec3.fromValues(0, 0, -1), vec3.fromValues(0, 1, 0));

            this.projectionMatrix = mat4.create();
            mat4.perspective(this.projectionMatrix, Math.PI / 3, 1, 1 / 1024, 1024);
        }

        setupGL() {
            const { ctx: gl } = this;

            gl.enable(gl.BLEND);
            // Needed for alpha and depth testing.
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.depthRange(1 / 1024, 1024);

            gl.depthMask(true);

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            this.setupShaders();
        }

        setupShaders() {
            const { ctx: gl } = this;

            const uniforms = [
                'u_model_matrix',
                'u_view_matrix',
                'u_projection_matrix',
                'u_colour',
                'u_opacity',
                'u_time',
            ];

            const attributes = [
                'a_position',
                'a_normal',
            ];

            // Version must be on the first line.
            const vertCode = `#version 300 es
                precision highp float;
                uniform mat4 u_model_matrix;
                uniform mat4 u_view_matrix;
                uniform mat4 u_projection_matrix;
                uniform float u_time;

                in vec3 a_position;
                in vec3 a_normal;

                out vec3 v_position;
                // Use flat shading for this normal.
                // flat out vec3 v_normal;
                out vec3 v_normal;

                void main(void) {
                    // This but for R4:
                    // https://en.wikipedia.org/wiki/Rotation_matrix#Basic_rotations
                    mat4 rotationX = mat4(1.);
                    rotationX[1][1] = cos(u_time);
                    rotationX[1][2] = sin(u_time);
                    rotationX[2][1] = -sin(u_time);
                    rotationX[2][2] = cos(u_time);

                    mat4 rotationY = mat4(1.);
                    rotationY[0][0] = cos(u_time);
                    rotationY[0][2] = sin(u_time);
                    rotationY[2][0] = -sin(u_time);
                    rotationY[2][2] = cos(u_time);

                    mat4 rotationZ = mat4(1.);
                    rotationZ[0][0] = cos(u_time);
                    rotationZ[0][1] = sin(u_time);
                    rotationZ[1][0] = -sin(u_time);
                    rotationZ[1][1] = cos(u_time);

                    mat4 rotation = rotationZ * rotationY * rotationX;
                    // Disable for now.
                    // rotation = mat4(1.);

                    gl_Position = u_projection_matrix * u_view_matrix * u_model_matrix * rotation * vec4(a_position, 1.);
                    gl_PointSize = 10.0;
                    v_position = a_position;
                    v_normal = a_normal;
                }
            `

            // Version must be on the first line.
            const fragCode = `#version 300 es
                precision highp float;
                uniform vec3 u_colour;
                uniform float u_opacity;

                in vec3 v_position;
                // Use flat shading for this normal.
                // https://community.khronos.org/t/reuse-same-normal-within-one-triangle/108081
                // flat in vec3 v_normal;
                in vec3 v_normal;
                out vec4 colour;

                void main(void) {
                    float falloff = 1. -  distance(vec3(0.), v_position) / 1.15;
                    falloff = 1.;
                    // In world space.
                    // Good for flat-shading.
                    // vec3 b_normal = normalize(cross(dFdx(v_position), dFdy(v_position)));
                    // vec3 normal = abs(normalize(b_normal));

                    vec3 normal = abs(normalize(v_normal));

                    colour = vec4(normal * falloff, u_opacity);
                }
            `

            this.state[SHADER_NAME] = new Shader(gl, vertCode, fragCode);
            this.state[SHADER_NAME].cacheUniformLocations(gl, uniforms);
            this.state[SHADER_NAME].cacheAttributeLocations(gl, attributes);

            // We reuse the same shader over and over, so we an make this the program we use right here.
            // If we need to switch shaders between draw calls, we'll then have to move this to draw()
            const { [SHADER_NAME]: shader } = this.state;
            const { program } = shader;           

            gl.useProgram(program);
        }

        setupBuffer(obj, type = 'ARRAY_BUFFER') {
            const { ctx: gl } = this;

            const bufferType = gl[type];
            if (obj.buffer) {
                gl.deleteBuffer(obj.buffer);
            }

            const buffer = gl.createBuffer();
            gl.bindBuffer(bufferType, buffer);
            gl.bufferData(bufferType, obj.data, gl.STATIC_DRAW);
            obj.buffer = buffer;
        }

        clear() {
            const { ctx: gl } = this;

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        }

        draw(obj, timestamp = 0) {
            const { ctx: gl } = this;
            const { buffer, callback, opacity, enabled, colour, hasIndices, hasNormals } = obj;
            const { [SHADER_NAME]: shader } = viz.state;
            const { program } = shader;
            if (!enabled) {
                return;
            }

            if (hasIndices && hasNormals) {
                // 'indexedMesh' case, per-vertex normals.
                // the vertices, though they are indexed (e.g. [-1.23, 0.3, 3.0, ...]).
                gl.bindBuffer(gl.ARRAY_BUFFER, obj.vertices.buffer);
                gl.vertexAttribPointer(shader.a_positionLocation, 3, gl.FLOAT, false, 12, 0);
                gl.enableVertexAttribArray(shader.a_positionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);

                // Assume it has normals.
                gl.bindBuffer(gl.ARRAY_BUFFER, obj.normals.buffer);
                gl.vertexAttribPointer(shader.a_normalLocation, 3, gl.FLOAT, false, 12, 0);
                gl.enableVertexAttribArray(shader.a_normalLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);

                // bind side by side with array_buffer
                // the triangles mapped by index to the vertices above (e.g. [0, 1, 2, 2, 1, 0]).
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.indices.buffer);
            } else if (hasNormals) {
                // 'regularMesh' case, per-triangle normals.
                gl.bindBuffer(gl.ARRAY_BUFFER, obj.buffer);
                gl.vertexAttribPointer(shader.a_positionLocation, 3, gl.FLOAT, false, 24, 0);
                gl.enableVertexAttribArray(shader.a_positionLocation);

                gl.vertexAttribPointer(shader.a_normalLocation, 3, gl.FLOAT, false, 24, 12);
                gl.enableVertexAttribArray(shader.a_normalLocation);
            } else {
                // Default case.
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.vertexAttribPointer(shader.a_positionLocation, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(shader.a_positionLocation);                
            }

            // TODO
            // Use a UBO.
            gl.uniform1f(shader.u_timeLocation, timestamp);

            gl.uniform3fv(shader.u_colourLocation, colour);
            gl.uniform1f(shader.u_opacityLocation, opacity);
            gl.uniformMatrix4fv(shader.u_model_matrixLocation, false, viz.modelMatrix);
            gl.uniformMatrix4fv(shader.u_view_matrixLocation, false, viz.viewMatrix);
            gl.uniformMatrix4fv(shader.u_projection_matrixLocation, false, viz.projectionMatrix);

            // Responsible for the actual draw calls.
            callback(gl);

            // Need to disable if it was previously enabled for the normal draw
            gl.disableVertexAttribArray(shader.a_positionLocation);
            gl.disableVertexAttribArray(shader.a_normalLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
    }

    function setupControls(viz, mc) {
        const gui = new dat.GUI();
        gui.width = gui.width * 1.5;

        const folderMarching = gui.addFolder('Marching Cubes');
        folderMarching.open();
        folderMarching.add(mc, 'size', 1, 100, 1).name('Box Size');
        folderMarching.add(mc, 'cubeSize', 0.005, 2, 0.001).name('Cube Size');
        folderMarching.add(mc, 'toggleInterpolate').name('Interpolate');

        const folderViz = gui.addFolder('Visualization');
        folderViz.open();
        {
            const max = 100;
            const min = -max;

            const props = ['x', 'y', 'z'];
            props.forEach(p => {
                const ctl = folderViz.add(viz.cameraPosition, p, min, max, 0.1);
                ctl.name(`Camera ${p}`);
                ctl.onChange(viz.setupMatrices);
            });
        }

        const folderDebug = gui.addFolder('Debug');
        folderDebug.open();
        folderDebug.add(mc, 'toggleMarchingCubesDebug').name('Show Cubes');
        folderDebug.add(mc, 'togglePerVertexNormals').name('Per Vertex Normals');

        // Just need a button to trigger marching again after changing params.
        gui.add(mc, "march").name('March');
        gui.add(mc, "nextSdf").name('Next Shape');
    }

    const { width, height } = document.getElementById('canvas');

    const sdf = new SDF();
    const viz = new Viz();
    const mc = new MarchingCubes(sdf, viz);

    setupControls(viz, mc);

        // Initial march until we recompute things based on controls interaction or animation.
    mc.march();

    const update = (timestamp) => {
        // After marching we can then update the visualization.
        // const time = timestamp * 0.00025;
        const time = timestamp * 0.0003;
        viz.clear();

        if (mc.toggleMarchingCubesDebug) {
            viz.draw(mc.state.grid, time);
        } else {
            viz.draw(mc.state.boundingBox, time);
        }

        // viz.draw(mc.state.mesh, time);
        if (mc.togglePerVertexNormals) {
            viz.draw(mc.state.indexedMesh, time);
        } else {
            if (mc.state.regularMesh.buffer) {
            viz.draw(mc.state.regularMesh, time);
            }
        }
        // viz.draw(mc.state.points, time);
        window.requestAnimationFrame(update);
    }

    window.requestAnimationFrame(update);

    </script>
</html>
